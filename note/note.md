### P 문제, NP 문제   
P 문제: 다항 시간 알고리즘이 존재하는 문제들의 집합     
NP 문제: 답이 주어졌을 때 이것이 원래 집합의 부분 집합인지, 그리고 원소들의 합이 S인지 다항 시간에 확인할 수 있는 문제들의 집합.   
  -> 모든 P 문제들은 NP문제에 포함됨.   
NP-Hard 문제: 다항 시간에 푸는 방법을 발견하지 못한 문제   
P=NP 문제: P와 NP가 같은지 확인하는 문제. 

## 알고리즘 증명 기법  
### 수학적 귀납법  
1. 단계 나누기 : 증명하고 싶은 사실을 여러 단계로 나누기  
2. 첫 단계 증명  
3. 귀납 증명 : 2가 성립한다면 다음 단계에서도 성립함을 보여줌  
  
#### 반복문 불변식(loop invariant)  
: 반복문의 내용이 한 번 실행될 때마다 중간 결과가 원하는 답으로 향하는지 명시하는 조건.  
1. 반복문 진입시에 불변식이 성립함을 보인다.  
2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다.  
3. 반복문 종료시에 불변식이 항상 성립되는지 보인다.  
```
//1. 불변식 성립 체크
while(조건){
...
//2. 불변식 성립 체크
... 
//3. 불변식 성립 체크
}
```

ex. 이진 탐색에서 불변식은 2개 쓰인다.  
start는 항상 end보다 작아야 하며, 찾는 값은 start와 end 사이에 있어야 한다.  


#### 귀류법  
원하는 바와 반대되는 상황을 가정하고 논리를 전개해서 결론이 잘못됐음을 찾아내는 증명 기법. 최선의 방법을 찾아낼 수 있다.  
ex.   
> 책장을 여러 개 쌓아올릴 때 최선의 방법은?
> 각 책장의 무게 + 견딜 수 있는 무게를 기준으로 정렬해서 순서대로 쌓는 방법
> 증명) 무게/견딜 수 있는 무게가 무거운 것이 가벼운 것 위에 올라갈 경우 안그래도 가벼운 책장은 견딜 수 있는 무게가 적은데다가 무거운 게 올라가서 비효율적임.

  
#### 비둘기집의 원리   
> 10마리의 비둘기가 9개의 비둘기집에 모두 들어갔다면, 2마리 이상이 들어간 비둘기집이 반드시 하나는 있기 마련이다.

예시: 서울의 모든 사람 중 머리털 개수가 같은 사람이 존재하는지 -> 시민 1000만명, 평균 머리털 10만개 -> 머리털 개수에 따라 방이 한칸씩 마련되어 있고, 해당되는 사람이 들어간다고 치면, 
비둘기집의 원리에 따라 2명 이상이 들어간 비둘기집이 반드시 하나는 있다.
  
예시2: 순환소수 찾기  
a%b의 결과는 b가지의 결과만 가질 수 있으니 결과가 중복되는 경우가 반드시 있다. 그래서 순환소수 패턴을 찾을 때 b+1번만 반복하면 패턴을 찾을 수 있다. 
b번에 나누어 떨어지면 순환소수가 아닌것이고, 나누어 떨어지지 않으면 무한소수이다. b+1번째에 기존에 나왔던 패턴이 나오면 순환소수이고, 0~b까지의 수가 아닌 다른 수가 나오거나, b번까지 반복했을 때 나온 패턴대로 나오지 않는다면 순환되지 않는 무한소수이다.


#### 구성적 증명   
답의 실제 예를 들면서 증명하는 방법.  


## 알고리즘 유형  
### 완전탐색   
- 모든 순열 만들기  
: permutations 함수 사용하는 것을 추천. nPr에서 n이 10을 넘어가면 시간 초과 가능성 큼.
- 모든 조합 만들기  
: 중첩 반복문 or 재귀로 풀이 가능  
nCr일 경우 재귀 깊이는 r까지
- 2^n가지 경우의 수 만들기  
: n개의 질문에 대한 답이 2가지일 때  

### 분할정복  
> 문제를 더 작은 문제로 분할(divide)
> 각 문제에서 나온 답을 원래 문제에 대한 답으로 병합(merge)
> 더 이상 문제를 분할하지 않아도 풀 수 있는 매우 작은 문제 (base case)

분할 정복은 한 번에 풀 수 없는 큰 문제를 base case까지 divide한 뒤, base case부터 한 단계씩 merge하면서 푸는 방식이다. 
 그래서 문제를 부분 문제로 나눌 수 있는 문제에만 적용될 수 있다.  
문제를 푸는 과정을 divide, merge, base case 문제 해결이라는 세 가지 모듈로 나눌 수 있으며, 같은 작업을 반복하기 때문에 빠르게 문제를 해결하게 해 준다.  

ex. 1부터 n까지 1씩 증가하는 등차수열의 합을 구할 때  
```
sum = 0
for number in range(1, n+1):
  sum += number
print(sum)
```
=> 이 방법은 시간 복잡도 O(N)이 걸린다. 이 문제는 분할 정복으로 더 빠르게 해결할 수 있다.  

```
sum = fast_sum(n)
print(sum)

###

def fast_sum(number):
  if number == 1: # 더 이상 분할할 수 없는 경우: base case
    return number
    
  if number % 2 == 1:
    return fast_sum(number-1) + number # 홀수일 경우 짝수와 1로 분할한다.
  return 2*fast_sum(number//2) + (number//2) * (number//2) # 짝수일 경우 
```

=> 이 방법은 재귀를 사용해 분할 정복으로 구현한 방법으로, O(logN)의 시간 복잡도를 가진다.  
=> (n*(n+1))/2 수식을 사용하면 바로 풀 수 있긴 하다.


